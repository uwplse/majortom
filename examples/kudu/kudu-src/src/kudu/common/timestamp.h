// Copyright (c) 2013, Cloudera, inc.
// Confidential Cloudera Information: Covered by NDA.

#ifndef KUDU_COMMON_TIMESTAMP_H_
#define KUDU_COMMON_TIMESTAMP_H_

#include <inttypes.h>
#include <string>

namespace kudu {
class faststring;
class Slice;
class Status;

// A transaction timestamp generated by a Clock.
class Timestamp {
 public:
  typedef uint64_t val_type;

  Timestamp() : v(kInvalidTimestamp.v) {}

  explicit Timestamp(uint64_t val) : v(val) {}

  bool operator ==(const Timestamp &other) const {
    return v == other.v;
  }
  bool operator !=(const Timestamp &other) const {
    return v != other.v;
  }

  // Decode a timestamp from the given input slice.
  // Mutates the slice to point after the decoded timestamp.
  // Returns true upon success.
  bool DecodeFrom(Slice *input);

  // Encode the timestamp to the given buffer.
  void EncodeTo(faststring *dst) const;

  int CompareTo(const Timestamp &other) const;

  std::string ToString() const;

  // Returns this Timestamp as an uint64_t
  uint64_t ToUint64() const;

  // Sets this Timestamp from 'value'
  Status FromUint64(uint64_t value);

  val_type value() const { return v; }

  // An initial transaction timestamp, higher than min so that we can have
  // a Timestamp guaranteed to be lower than all generated timestamps.
  static const Timestamp kInitialTimestamp;

  // An invalid transaction timestamp -- Timestamp types initialize to this variable.
  static const Timestamp kInvalidTimestamp;

  // The maximum timestamp.
  static const Timestamp kMax;

  // The minimum timestamp.
  static const Timestamp kMin;

 private:
  val_type v;
};

inline std::ostream &operator <<(std::ostream &o, const Timestamp &timestamp) {
  return o << timestamp.ToString();
}

inline int Timestamp::CompareTo(const Timestamp &other) const {
  if (v < other.v) {
    return -1;
  } else if (v > other.v) {
    return 1;
  }
  return 0;
}

} // namespace kudu

#endif /* KUDU_COMMON_TIMESTAMP_H_ */
